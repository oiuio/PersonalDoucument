# 考前串讲

[toc]

## 上午考试情况

| 科目                 | 重要知识点                                                     |
| -------------------- | -------------------------------------------------------------- |
| 软件工程基础知识     | **开发模型、  McCabe复杂度计算、  软件维护类型、Gant图与Pert** |
| 图面向对象           | **面向对象基本概念、UML、设计模式**                            |
| 数据结构与算法       | **栈与队列、树与二叉树、查找与排序、时间复杂度**               |
| 程序设计语言         | **正规式、传值与传址调用、有限自动机**                         |
| 计算机组成与体系结构 | **数据的表示、分层存储体系、流水线**                           |
| 操作系统             | **前趋图与PV操作、  死锁问题、段页式存储与页面置换算法**       |
| 数据库系统           | **E-R模型、 关系代数、规范化理论(键、范式、模式分解)**         |
| 计算机网络           | **TCP/IP协议族、子网划分**                                     |
| 信息安全知识         | **加密技术与数字证书、网络安全协议、防火墙**                   |
| 多媒体基础           | **媒体的类型**                                                 |
| 知识产权与标准化     | **侵权判定，知识产权归属**                                     |

---
## 系统开发基础

### 软件开发模型
* 瀑布模型
* V模型
* 喷泉模型
* 原型化模型
* 演化
* 螺旋
* 统一过程
* 敏捷

### CcCabe复杂度
* V(G) = m - n + 2 m：弧度，n节点数

### 软件维护
* 可维护因素决定：可理解性、可测试性、可修改性
* **软件维护类型**： 改正性维护、适应性维护、预防性维护、完善性维护
    * **适应性维护：** 适应外部环境和管理需求
    * **完善性：** 扩充功能和改善性能

### 项目管理
* **gant图：** 并行情况、不能展示依赖关系
* **pert图：** 展示依赖关系、不能展示并行情况
* **最短完成时间：** 关键路径
* **最早、最晚完成时间：** 从前、从后

---

## 面向对象技术
#### 概念
* **对象 :** 属性(数据) + 方法(操作) + 对象ID
* **类 :** 实体类(数据),控制类(类之间协调),边界类(对外接口)
* **继承与泛化 :** 复用机制
* **封装 :** 隐藏对象的属性和实现细节,仅对外公开接口
* **多态 :** 不同对象收到 **同样的信息** 产生不同的结果
* **接口 :** 一种特殊的类,他只有方法定义没有实现
* **重载 :** 一个类可以有多个 **同名而参数类型不同的方法**
* **模板类**
* **消息和消息通信 :** 消息是异步通信的

#### 面向对象设计7大原则
* **单一职责原则 :** 设计目的单一的类
* **开放-封闭原则 :** 对扩展开放，对修改封闭
* **李氏(Liskov)替换原则 :** 子类可以替换父类
* **依赖倒置原则 :** 要依赖于抽象，而不是具体实现;针对接口编程，不要针对实现编程
* **接口隔离原则 :** 使用多个专门的接口比使用单一的总接口要好
* **组合重用原则 :** 要尽量使用组合，而不是继承关系达到重用目的
* **迪米特(Demeter)原则(最少知识法则) :** 一个对象应当对其他对象有尽可能少的了解

#### UML 
|                |                      |                                                        |
| -------------- | -------------------- | ------------------------------------------------------ |
| 结构图(静态图) | 类图                 | /                                                      |
| ^              | 对象图               | /                                                      |
| ^              | 包图*                | /                                                      |
| ^              | 聚合结构图*          | /                                                      |
| ^              | 构建图               | /                                                      |
| ^              | **部署图**           | 软硬件之间的映射                                       |
| ^              | 制品图               | /                                                      |
| 行为图(动态图) | **用例图(争议)**     | 系统与外部参与者的交互                                 |
| ^              | **时序/顺序/序列图** | 强调按时间顺序                                         |
| ^              | **通信图(协作图)**   | (与上面称为交互图) 强调对象之间组织结构                |
| ^              | 定时图*              | /                                                      |
| ^              | 状态图               | 状态图描述一个状态机，它由状态、转移、事件和活动组成。 |
| ^              | **活动图**           | 类似程序流程图,并行行为                                |
| ^              | 交互概览图           | /                                                      |

#### 类图
| 类图            |                                           |                                                                                                                                                        |                              |
| --------------- | ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------- |
| 一般关系(is-a)  | 泛化(继承)关系<br>Generalization          | 特殊/一般关系                                                                                                                                          | ———▷/▶<br>指向父类        |
| ^               | 实现关系<br>Realization                   | 类与接口的关系                                                                                                                                         | — — —▷<br>指向接口        |
| 关联关系(has-a) | 关联关系<br>Association                   | 一种拥有关系,它使一个类知道另一个类的属性和方法<br>双向的关联可以有两个箭头或者没有箭头,单向的关联有一个箭头.两端可以有1:n n:n<br>还有自身关联指向自己 | —————><br>指向被拥有者  |
| ^               | 聚合关系(has-a)<br>Aggregation            | 是整体与部分的关系，且部分可以离开整体而单独存在(生命周期不同)。                                                                                       | —————◇<br>指向整体      |
| ^               | 组合(合成)关系(contains-a)<br>Composition | 是整体与部分的关系，但部分不能离开整体而单独存在(生命周期相同)。                                                                                       | —————◆<br>指向整体      |
| 依赖关系(use-a) | 依赖关系<br>Dependency                    | 一个事物发生变化会影响另一个事物<br>一种使用的关系，即一个类的实现需要另一个类的协助                                                                   | — — — —><br>指向被使用者 |

#### 设计模式分类
| 分类   | 设计模式名称                              | 简要说明                                                                                                                   | 速记关键字                   |
| ------ | ----------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- | ---------------------------- |
| 创建型 | Abstract Factory<br>抽象工厂模式          | 提供一个创建一系列相关或相关依赖对象的接口,而无需指定他们具体的类                                                          | 生产**系列**对象             |
| ^      | Factory Method<br>工厂方法模式            | 定义一个创建对象的接口, 让子类决定实例化哪一个类, 工厂方法使一个类的实例化延伸到了子类                                     | 动态产生对象                 |
| ^      | Build<br>构建器模式                       | 将一个复杂类的表示与其构造相分离,使得相同的构建过程能够得出不同的表示                                                      | 复杂对象构造                 |
| ^      | Prototype<br>原型模式                     | 用原型实例指定创建对象的类型,并且通过拷贝这个原型来创建新的对象                                                            | 克隆对象                     |
| ^      | **Singleton<br>单例模式**                 | 保证一个类只有一个实例,并提供一个访问它的全局访问点                                                                        | 单实例                       |
| 结构型 | **Adapter<br>适配器模式**                 | 将一个类的接口转换成用户希望得到的另一种接口. 它使得原本不相容的接口得以协同工作                                           | **转换**接口                 |
| ^      | Bridge<br>桥接模式                        | 将类的抽象部分和它的实现部分分离开,使他们可以独立的变化                                                                    | 继承树拆分                   |
| ^      | Composite<br>组合模式                     | 将对象组合成树形结构表示"整体-部分"的层次结构,使得用户对单个对象和组合对象的使用具有一致性                                 | 树形目录结构                 |
| ^      | **Decorator<br>装饰模式**                 | 动态地给一个对象添加一些额外的职责. 它提供了子类扩展功能的一个灵活的替代,比派生一个子类更加灵活                            | **附加职责**                 |
| ^      | Facade<br>外观模式                        | 定义一个高层结构,为子系统中的一组接口提供一个一致的外观,从而简化了该子系统的使用                                           | 对外统一接口                 |
| ^      | Flyweight<br>享元模式                     | 支持大量细粒度对象共享的有效方法                                                                                           | 文章共享文字对象             |
| ^      | Proxy<br>代理模式                         | 对其他对象提供一种代理以控制这个对象的访问                                                                                 | 两者之间不直接通信           |
| 行为型 | **Chain of Reposnsibility<br>职责链模式** | 通过给多个对象处理请求的机会,减少请求的发送与接收者之间的耦合.讲接收对象链接起来,在链中传递请求,直到有一个对象处理这个请求 | 传递职责                     |
| ^      | **Command<br>命令模式**                   | 将一个请求封装为一个对象,从而可用不同的请求对客户进行参数化,将请求排队或记录请求日志,支持可撤销操作                        | 日志记录,可撤销              |
| ^      | Interpreter<br>解释器模式                 | 给定一种语言,定义它的文法表示,并定义一个解释器.该解释器用来根据文法表示来解释语言中的句子                                  | 虚拟机的机制                 |
| ^      | Iterator<br>迭代器模式                    | 提供一种方法来顺序访问一个聚合对象中的各个元素,而不需要暴露该对象的内部表示                                                | 数据库数据集                 |
| ^      | Mediator<br>中介者模式                    | 用一个中介对象来封装一系列的对象交互.它使各对象不需要显示地互相调用,从而达到低耦合,还可以独立地改变对象间的交互            | 不直接引用                   |
| ^      | Memento<br>备忘录模式                     | 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态,从而可以在以后讲该对象恢复到原先保存的状态        | (记录)                       |
| ^      | **Observer<br>观察者模式**                | 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖它的对象都得到通知并自动更新                           | 联动(一个被观察者多个观察者) |
| ^      | State<br>状态模式                         | 允许一个对象在其内部状态改变时改变它的行为                                                                                 | 状态改变行为                 |
| ^      | **Strategy<br>策略模式**                  | 定义一系列算法,把它们一个个封装起来,并且使它们之间可以互相替换,从而让算法可以独立于使用它的用户而变化                      | 多方案切换                   |
| ^      | Template Method<br>模板方法模式           | 定义一个操作中的算法骨架,而将一些步骤延迟到子类中,使得子类可以不改变一个算法的结构即可重新定义算法的某些步骤               | /                            |
| ^      | Visitor<br>访问者模式                     | 表示一个作用于某个对象结构中的各元素操作,使得在不改变各元素的类的前提下定义作用于这些元素的新操作                          | /                            |

---
## 数据结构与算法基础
* **队列与栈：**先进先出、先进后出
* **满二叉数、完全二叉树**
* **二叉树遍历：**
* **二插排序树：**
* **平衡二叉树：**
* **最有二叉树(Huffman)：**

### 查找
* 顺序查找：
* 二分：
* 散列表：计算

### 排序
* 稳定与不稳定排序、内排序与外排序
* **插入类排序：**
* **交换类排序：**
* **选择类排序：**
* **归并排序：**
* **基数排序：**

| 方式                 | 时间复杂度平均 | 最坏          | 辅助存储     | 稳定   |
| -------------------- | -------------- | ------------- | ------------ | ------ |
| 直接插入排序         | $O(n^2)$       | $O(n^2)$      | $O(1)$       | 稳定   |
| 希尔排序             | $O(n^{1.3})$   | $O(n^2)$      | $O(1)$       | 不稳定 |
| 直接（简单）选择排序 | $O(n^2)$       | $O(n^2)$      | $O(1)$       | 不稳定 |
| 堆排序               | $O(n\log_2n)$  | $O(n\log_2n)$ | $O(1)$       | 不稳定 |
| 冒泡排序             | $O(n^2)$       | $O(n^2)$      | $O(1)$       | 稳定   |
| 快速排序             | $O(n\log_2n)$  | $O(n^2)$      | $O(\log_2n)$ | 不稳定 |
| 归并排序             | $O(n\log_2n)$  | $O(n\log_2n)$ | $O(n)$       | 稳定   |
| 基数排序             | $O(d(r+n))$    | $O(d(r+n))$   | $O(r+n)$     | 稳定   |

### 数据挖掘算法
* 从各类爆炸式增长的数据中提取有价值的信息
* 分类、回归、关联规则、聚类

### 智能优化算法
* 求解各种工程问题优化解的应用技术
* **人工神经网络：** 以有向图为拓扑结构的动态技术
* **遗传算法：** 基于自然选择及群体遗传学基础
* **模拟退火算法：** 求解全局优化算法，源于物理退火过程
* **禁忌搜索算法：** 模拟人类智力过程的一种全局搜索算法
* **蚁群算法：** 模拟生物蚁群信息交流与协作
* **粒子群优化算法：** 基于生物群体中的信息共享机智

---

## 程序设计语言与语言处理程序基础
* **编译过程：** 解释型、编译型
* **词法分析**、**语法分析**、**（静态）语义分析**、（中间代码生成、代码优化）、目标代码生成、目标程序
* **函数调用：** 传址、传值

---

## 操作系统 
* **前驱图**
* **PV操作**
    * 单缓冲区：阻塞、唤醒
* 段页式存储：
    * **页式存储：逻辑地址与物理地址的变化。每个页大小固定**
        * 有点：利用率高、碎片小、分配及管理简单
        * 缺点：增加了系统开销；可能产生抖动现象
            * 查页表，缺页中断增加消耗
    * **段式存储：逻辑地址合法性判断。每个段的大小是不固定的**
        * 优点：多道程序共享内存，各段程序修改互不影响
        * 缺点：内存利用率低，内存碎片浪费大
            * 程序根据程序方法大小分成段
    * 未说明页面置换算法时，按LRU算法执行：最近未被访问，访问为0，在修改位为0

---

## 数据库系统
* **并、交、叉、笛卡儿积、投影、选择、联接、自然连接**
* **规范化理论：**
    * **求候选键：** A,B 与AB 区别
    * **主属性：** 构成候选键的属性
    * **1NF、2NF、3NF、BCNF**
    * **模式分解**
        * 有损/无损连接：表格法
        * 保持函数依赖
        * 公式法:R1∩R2→（R1-R2）或R1∩R2→（R2-R1）

---

## 计算机网络与信息安全

### OSI/RM七层模型
|     |            |                              |                                                         |
| --- | ---------- | ---------------------------- | ------------------------------------------------------- |
| 7   | 应用层     | 实现具体的应用功能           | P0P3、FTP、HTTP、Telnet、SMTP <br>DHCP、TFTP、SNMP、DNS |
| 6   | 表示层     | 数据的格式与表达、加密、压缩 | ^                                                       |
| 5   | 会话层     | 建立、管理和终止会话         | ^                                                       |
| 4   | 传输       | 端到端的连接                 | TCP、UDP                                                |
| 3   | 网络       | 分组传输和路由选择           | 三层交换机、路由器<br>ARP、RARP、IP、ICMP、IGM          |
| 2   | 数据链路层 | 传送以帧为单位的信息         | 网桥、交换机、网卡<br> PPTP、L2TP、SLIP、PPP            |
| 1   | 物理层     | 进制传输                     | 中继器、集线器                                          |

### 各层安全协议
|     |            |                       |
| --- | ---------- | --------------------- |
| 7   | 应用层     | SSL、PGP、Https       |
| 6   | 表示层     | SSL、                 |
| 5   | 会话层     | SSL、                 |
| 4   | 传输       | SSL、TLS、SET（交易） |
| 3   | 网络       | 防火墙、IPSec         |
| 2   | 数据链路层 | 链路加密、PPTP、L2TP  |
| 1   | 物理层     | 隔离、屏蔽            |


### TCP/IP
|     |            |            |                                     |     |                                |
| --- | ---------- | ---------- | ----------------------------------- | --- | ------------------------------ |
| 7   | 应用层     | 应用层     | POP3 、FTP<br>HTTP、 SMTP<br>TELNET | NFS | DHCP、TFTP<br>SNMP、DNS<br>UDP |
| 6   | 表示层     | ^          | ^                                   | ^   | ^                              |
| 5   | 会话层     | ^          | ^                                   | ^   | ^                              |
| 4   | 传输       | 传输       | TCP                                 | /   |                                |
| 3   | 网络       | 网际层     | IP、ICMP、IGMP、ARP、RARP           |     |                                |
| 2   | 数据链路层 | 网络接口层 | CSMA/CO、TokingRing                 |     |                                |
| 1   | 物理层     | ^          | ^                                   |     |                                |

---

## 媒体种类
* 感觉媒体：声音、图像、动画
* 表示媒体：编码方式
* 显示媒体（表现媒体）：IO设备
* 存储媒体：
* 传输媒体：

---
## 面向对象程序设计
* 定义类型问题较多：interface,implements,extends,abstract
* 考察调用关系较多

---
## 数据结构及算法应用
* 分治法：
    * 把一个问题拆分乘多个小规模的相同子问题，一般可以用递归解决。
    * 经典问题：
        * **斐波那契数列**、归并排序、快速排序、**矩阵乘法**、二分搜索、大整数乘法、汉诺塔
* 动态规划法（求最优解/最优子结构）
    * 划分子问题，并把自问题结果使用数据存储，利用查询子问题的结果构造最终问题结果
    * 经典问题：
        * **斐波那契数列**、矩阵乘法、**背包问题**、LCS最长公共子序列
* 回溯法
    * 搜索一个问题的所有解或者任一解，过程中会回溯
    * 经典问题：
        * N皇后问题、迷宫、**背包问题**
* 贪心法（满意解）
    * 局部最优、但不见得整体最优。
    * 经典问题：
        * **背包问题（装箱）**、多机调度、找零钱问题
* 时间复杂度总结
    * $ O(1) < O(\log_2n) < O(n) < O(n\log_2n) < O(n^2) < O(n^3) < O(2^n) $
    * $O(\log_2n)$ 二叉树：二分查找
    * $O(n\log_2n)$ 堆排序：每次求一次极值，需要n次

---

## UML图
* 用例图：包含关系、扩展关系、泛化关系
    * 找出动词
* 类图
    * 找出名词
---

## 数据库设计
* 补充实体联系
* 补充关系模式
* 分析规范化问题
---

## 数据流图
* 补充实体
    * 人物角色、组织机构、外部系统
* 补充存储
    * xx文件、xx表、xx库、xx清单、xx档案
* 补充数据流图
    * 顶层图与0曾图对比
    * 检查加工：是凑存在只有入没有出、或只有出没有入
    * 按题目说明匹配
* 补充加工名
    * 找动词+名词